---
title: "Regression Feature Selection Wrapper: XGBoost w/ BCOGC data"
author: "Scott McKean"
output:
  pdf_document: default
  html_document: default
---

# Geoscience BC Study Code - Machine Learning Wrapper

```{r setup, include=FALSE}
library(geosciencebc2019008)
run_date = Sys.Date() %>% str_replace_all(., "-", "_")

model_prefix = 'glm_wcfd'
```

## ML Dataframe Prep

This chunk prepares our dataframe for clustering, statistical modelling, and other data science techniques. It specifies auxillary columns (those useful for information), predictor columns, and our target column(s): seimogenic (T/F) and max magnitude (numeric).

For the regression problem, we focus exclusively on wells that have generated earthquakes. The dataset is therefore quite a bit smaller, but non-seismogenic wells provide no information regarding the maximum magnitude of earthquake generated by an event.

```{r}
target = "max_mag"

aux_cols <- c(
  "unique_surv_id", "wa_num", "drilling_event", "ground_elevtn",
  "mean_easting", "mean_northing", "on_prod_date",
  "last_reported_date", "cum_gas_to_date_e3m3", "cum_oil_to_date_m3",
  "cum_water_to_date_m3", "cum_cond_to_date_m3", "frac_start_date",
  "frac_end_date", "min_dist_well", "calc_completed_length_m")
```

## Load and subset data

```{r}
# load prepared data
ml_df <- read_rds('../wcfd_data/wcfd_mldf.rds') %>%
  dplyr::filter(seismogenic == 1) %>%
  dplyr::select(-'seismogenic', -aux_cols)
```

## Feature Selection

```{r}
# normalize features to speed model fitting
norm_ml_df <- normalizeFeatures(ml_df, target = target)

# task
regr_tsk = makeRegrTask(data = norm_ml_df, target = target)

# learner
regr_lrn = makeLearner("regr.glm")
```

## filter-based feature importance

```{r}
plot_regr_filt_importance(regr_tsk,
paste0('../output/',model_prefix,"_"))
```

```{r}
## wrapper-based feature importance - sequential forward sampling
for (alpha in seq(9.41E-4, 9.9E-4, length.out = 20)){
  i = which(alpha == seq(9.41E-4, 9.9E-4, length.out = 20))
  
  regr_feats_seq = suppressWarnings(selectFeatures(
  learner = regr_lrn, task = regr_tsk, resampling = cv5,
  control = makeFeatSelControlSequential(method = 'sfbs', alpha = alpha, maxit = 4000), measures = list(mae, rmse), show.info = FALSE
  ))

  print(i)
  saveRDS(
    regr_feats_seq,
    paste0('../output/regr_feats_',model_prefix,'/seq_',i,'.rds')
    )
}
```

## Wrapper-based feature importance - SFBS parsing

This chunk parses the wrapper-based sequential feature selection results in order to calculate the most important features and produces a plot.

```{r}
regr_feats_seq_files = list.files(
  paste0('../output/regr_feats_',model_prefix), 
  pattern = "seq", full.names = TRUE
  )

for (file in regr_feats_seq_files){
  feat_res = read_rds(file)
  
  if (file == regr_feats_seq_files[1]){
    path = feat_res$opt.path$env$path
  } else {
    path = rbind(path, feat_res$opt.path$env$path)
  }
}

plot_regr_feat_seq(
  path, paste0('../output/',model_prefix),
  n_best_val = 1000
  )

```

## Wrapper-based feature importance - random loop

We also use random sampling for feature selection. This is more robust to non-convergence, but requires a lot of trials (we use 100,000).

```{r}
## wrapper-based feature importance - random sampling
for (i in 1:100){
  regr_feats_rand = suppressWarnings(selectFeatures(
    learner = regr_lrn, task = regr_tsk, resampling = cv5,
    control = makeFeatSelControlRandom(maxit = 1000), 
    measures = list(mae, rmse), show.info = FALSE
    ))
  
  print(i)
  saveRDS(
    regr_feats_rand, 
    paste0('../output/regr_feats_',model_prefix,'/rand_',i,'.rds')
    )
}
```

## Wrapper-based feature importance - random loop

This chunk parses the random sampling results.

```{r}
regr_feats_rand_files = list.files(
  paste0('../output/regr_feats_',model_prefix), 
  pattern = "rand",
  full.names = TRUE
  )

for (file in regr_feats_rand_files){
  feat_res = read_rds(file)
  
  if (file == regr_feats_rand_files[1]){
    path = feat_res$opt.path$env$path
  } else {
    path = rbind(path, feat_res$opt.path$env$path)
  }
}

plot_regr_feat_rand(
  path, paste0('../output/',model_prefix), 
  n_best_val = 1000
  )
```